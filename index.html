<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Spelling Trainer</title>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" crossorigin="anonymous" referrerpolicy="no-referrer"/>
<style>
:root{
  --page-bg:#eceff1;
  --card-bg:#fff;
  --muted:#cfcfcf;
  --muted-2:#bfbfbf;
  --accent-green:#4CAF50;
  --accent-yellow:#FFC107;
  --accent-red:#F44336;
  --card-width:760px;
  --shadow:0 10px 30px rgba(20,20,30,0.06);
  --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, "Roboto Mono", "Courier New", monospace;
}
html,body{height:100%;margin:0;font-family:system-ui,-apple-system,"Segoe UI",Roboto,Arial;background:var(--page-bg);color:#222}
.wrap{min-height:100%;display:flex;align-items:center;justify-content:center;padding:28px}
.card{width:100%;max-width:var(--card-width);background:var(--card-bg);border-radius:18px;box-shadow:var(--shadow);padding:20px;box-sizing:border-box}
header{display:flex;align-items:center;justify-content:space-between;margin-bottom:12px}
header h1{font-size:18px;margin:0}
nav{display:flex;gap:8px}
nav button{border:none;background:transparent;padding:8px 12px;border-radius:10px;cursor:pointer;color:#555;font-weight:700}
nav button.active{background:#dfe4e7;color:#111}

/* top row */
.play-row { display:flex; gap:10px; align-items:center; justify-content:center; margin-bottom:8px; }
.btn-play { display:inline-flex; align-items:center; justify-content:center; background:var(--muted-2); color:#fff; border-radius:12px; padding:0 12px; border:none; cursor:pointer; min-width:48px; height:44px; box-sizing:border-box; }
.btn-play[disabled]{ opacity:0.6; cursor:not-allowed; }
.icon-btn { background:var(--muted-2); color:#fff; border:none; padding:0; width:44px; height:44px; display:inline-flex; align-items:center; justify-content:center; border-radius:12px; cursor:pointer; box-sizing:border-box; }
.icon-btn[title]:hover { filter:brightness(.97); }

/* keep a minimal visual label area to the right (result text) */
.result { font-weight:700; color:#444; min-width:0; flex:1; text-align:center; }

/* text input */
input.word-input{flex:1;padding:10px 12px;border-radius:12px;border:1px solid #e6e6e6;font-size:16px;min-width:220px;box-sizing:border-box;height:44px}

/* hint below input */
.hint-line { margin-top:8px; font-family:var(--mono); color:#999; text-align:center; min-height:20px; transition:opacity .25s ease; }

/* feedback bar */
.feedback-wrap { width:100%; display:flex; justify-content:center; margin-top:8px }
.feedback-bar { width:100%; display:flex; gap:10px; position:relative; align-items:center; padding:6px 0; }
.segment { flex:1; height:14px; background:var(--muted); border-radius:10px; transition:background .22s ease, flex .22s ease, width .22s ease; position:relative; }
.merged { position:absolute; height:14px; background:var(--accent-green); border-radius:10px; transition:left .22s ease, width .22s ease, opacity .22s ease; opacity:0; pointer-events:none; }

/* controls/mode toggles */
.controls { display:flex; gap:10px; margin-top:12px; align-items:center; }
.score-area { position:relative; display:flex; align-items:center; gap:8px; min-width:110px; justify-content:flex-end }
.score { font-weight:800; color:#222 }

/* Auto Next button: when ON -> white with light grey outline; OFF -> grey like other buttons */
.auto-btn {
  display:inline-flex;
  align-items:center;
  justify-content:center;
  gap:8px;
  padding:0 14px;
  height:44px;
  border-radius:12px;
  border:1px solid transparent;
  background:var(--muted-2);
  color:#fff;
  cursor:pointer;
  min-width:140px;
  box-sizing:border-box;
  font-weight:700;
}
.auto-btn.checked {
  background:#fff;
  color:#111;
  border:1px solid #e6e6e6;
}

/* settings segmented controls */
.segmented { display:flex; gap:6px; background:transparent; border-radius:10px; padding:6px }
.segmented button { background:transparent; border:none; padding:8px 10px; border-radius:8px; cursor:pointer; color:#666; font-weight:700; position:relative; }
.segmented button.on { background:#e6e9ea; color:#111 }

/* settings rows */
.settings-row { display:flex; gap:12px; align-items:center; margin:8px 0; }
.label { min-width:110px; font-size:14px; color:#666 }
.control { flex:1; display:flex; align-items:center; gap:8px }

/* select */
.select { padding:10px 12px; border-radius:10px; border:1px solid #e6e6e6; background:#fff; font-size:14px; width:100%; box-sizing:border-box; }

/* stats */
.stats-list { display:flex; flex-direction:column; gap:8px; margin-top:8px; }
.stat-row { display:flex; gap:12px; align-items:center; justify-content:space-between; padding:8px; border-radius:10px; background:#fbfbfb; border:1px solid #f0f0f0 }
.stat-left { display:flex; align-items:center; gap:8px; flex:1; font-weight:600; }
.stat-right { display:flex; align-items:center; gap:12px; width:300px; justify-content:flex-end; }

/* mini bar */
.mini-bar { display:flex; gap:6px; width:180px; height:12px; align-items:center; position:relative; }
.mini-seg { flex:1; height:100%; border-radius:8px; transition:background .18s ease; background:var(--muted); position:relative; }

/* tooltip */
.mini-tooltip { position:fixed; z-index:9999; padding:6px 8px; border-radius:6px; color:#fff; font-weight:700; font-size:12px; white-space:pre-line; pointer-events:none; transform:translateY(-6px); opacity:0; transition:opacity .12s ease, transform .12s ease; }

/* small text */
.small { font-size:13px; color:#666 }

/* responsive */
@media (max-width:760px){
  .card{padding:14px}
  .stat-right{width:200px}
  .label{min-width:84px}
  .result{ font-size:14px; text-align:center; }
}

  /* --- Make main game buttons perfect squares --- */
/* Put this AFTER your existing styles so it overrides previous width/padding rules. */

:root {
  --main-icon-size: 48px; /* change to 40/44/56 if you want bigger/smaller squares */
}

/* Base square style for all game-row icon buttons */
.btn-play,
.icon-btn,
.auto-btn {
  width: var(--main-icon-size) !important;
  height: var(--main-icon-size) !important;
  padding: 0 !important;               /* remove horizontal padding so it's a square */
  min-width: 0 !important;             /* override any min-width */
  display: inline-flex !important;
  align-items: center !important;
  justify-content: center !important;
  border-radius: 12px !important;      /* match other buttons' rounding */
  box-sizing: border-box !important;
}

/* keep icon size legible inside the square */
.btn-play i,
.icon-btn i,
.auto-btn i {
  font-size: 18px; /* tweak for balance; increase to 20-22 for larger squares */
  line-height: 1;
  pointer-events: none;
}

/* ensure the auto-btn (which previously had extra padding/checked state) still styles correctly */
.auto-btn {
  padding: 0 !important;
}

/* hover & focus visual stability */
.btn-play:hover,
.icon-btn:hover,
.auto-btn:hover,
.btn-play:focus,
.icon-btn:focus,
.auto-btn:focus {
  filter: brightness(.98);
  outline: none;
}

/* disabled state keeps square look */
.btn-play[disabled],
.icon-btn[disabled],
.auto-btn[disabled] {
  opacity: 0.55;
  cursor: not-allowed;
}

/* If you have textual buttons inside the same container, ensure spacing doesn't collapse */
.play-row { gap: 12px; align-items: center; }

/* Optional: smaller squares on mobile */
@media (max-width:480px){
  :root { --main-icon-size: 44px; }
  .btn-play i,
  .icon-btn i,
  .auto-btn i { font-size: 16px; }
}

  
</style>
</head>
<body>
  <div class="wrap">
    <div class="card" role="application" aria-label="Spelling trainer">
      <header>
        <h1>Spelling Trainer</h1>
        <nav>
          <button id="tabGame" type="button" class="active">Game</button>
          <button id="tabStats" type="button">Stats</button>
          <button id="tabSettings" type="button">Settings</button>
        </nav>
      </header>

      <main>
        <!-- GAME -->
        <section id="pageGame">
          <div class="play-row" style="width:100%;">
            <button id="btnPlay" class="btn-play" title="Play"><i class="fa-solid fa-play" style="font-size:14px"></i></button>
            <input id="inputAnswer" class="word-input" placeholder="Type what you hear..." autocomplete="off" />
            <div class="result" id="resultText" aria-live="polite"></div>
          </div>

          <div class="hint-line" id="hintLine" aria-hidden="true"></div>

          <div class="feedback-wrap">
            <div class="feedback-bar" id="feedbackBar" aria-hidden="true">
              <div class="merged" id="mergedBar"></div>
            </div>
          </div>

          <div class="controls">
            <button id="btnCheck" class="icon-btn" type="button" title="Check"><i class="fa-solid fa-square-check" aria-hidden="true"></i></button>
            <button id="btnNext" class="icon-btn" type="button" title="Next"><i class="fa-solid fa-forward" aria-hidden="true"></i></button>
            <button id="autoNextBtn" class="icon-btn auto-btn" type="button" aria-pressed="false" title="Auto Next"><i class="fa-solid fa-arrows-spin" aria-hidden="true"></i></button>

            <div style="flex:1"></div>

            <div class="score-area">
              <div class="score" id="scoreText">Score: 0</div>
            </div>
          </div>
        </section>

        <!-- STATS -->
        <section id="pageStats" style="display:none">
          <div style="display:flex;justify-content:space-between;align-items:center">
            <div class="small" id="statsSummary">Total: 0 | Accuracy: 0%</div>
            <div>
              <button id="btnClearStats" class="btn small" style="background:#f2f2f2;color:#333" type="button">Wipe</button>
            </div>
          </div>
          <div class="stats-list" id="statsList"></div>
        </section>

        <!-- SETTINGS -->
        <section id="pageSettings" style="display:none">
          <div style="display:flex;flex-direction:column;gap:12px">
            <div class="settings-row">
              <div class="label">Difficulty</div>
              <div class="control">
                <div class="segmented" id="segDifficulty">
                  <button data-val="easy" type="button">Easy</button>
                  <button data-val="advanced" type="button">Advanced</button>
                  <button data-val="proficient" type="button">Proficient</button>
                </div>
              </div>
            </div>

            <div class="settings-row">
              <div class="label">Mode</div>
              <div class="control">
                <div class="segmented" id="segMode">
                  <button data-val="normal" type="button">Normal</button>
                  <button data-val="easy" type="button">Easy</button>
                  <button data-val="hardcore" type="button">Hardcore</button>
                </div>
              </div>
            </div>

            <div class="settings-row">
              <div class="label">TTS Voice</div>
              <div class="control">
                <select id="voiceSelect" class="select" aria-label="Select TTS voice">
                  <option value="">Loading voices…</option>
                </select>
              </div>
            </div>

            <div class="small" style="color:#666">made with ❤️ (and chatgpt) by daniel</div>
          </div>
        </section>
      </main>
    </div>
  </div>

<!-- embedded fallback words -->
<script id="embeddedWords" type="application/json">
{
  "words":[
    {"word":"abandon","level":"easy"},{"word":"bravery","level":"easy"},{"word":"elegant","level":"easy"},{"word":"harvest","level":"easy"},{"word":"journey","level":"easy"},
    {"word":"meticulous","level":"advanced"},{"word":"resilient","level":"advanced"},{"word":"transcendent","level":"advanced"},{"word":"alleviate","level":"advanced"},{"word":"benevolent","level":"advanced"},
    {"word":"juxtaposition","level":"proficient"},{"word":"idiosyncrasy","level":"proficient"},{"word":"ephemeral","level":"proficient"},{"word":"conscientious","level":"proficient"},{"word":"magnanimous","level":"proficient"}
  ]
}
</script>

<script>
(() => {
  // DOM
  const tabGame = document.getElementById('tabGame'), tabStats = document.getElementById('tabStats'), tabSettings = document.getElementById('tabSettings');
  const pageGame = document.getElementById('pageGame'), pageStats = document.getElementById('pageStats'), pageSettings = document.getElementById('pageSettings');

  const btnPlay = document.getElementById('btnPlay'), btnCheck = document.getElementById('btnCheck'), btnNext = document.getElementById('btnNext');
  const inputAnswer = document.getElementById('inputAnswer'), hintLine = document.getElementById('hintLine');
  const feedbackBar = document.getElementById('feedbackBar'), mergedBar = document.getElementById('mergedBar');
  const resultText = document.getElementById('resultText'), scoreText = document.getElementById('scoreText');

  const statsList = document.getElementById('statsList'), statsSummary = document.getElementById('statsSummary'), btnClearStats = document.getElementById('btnClearStats');
  const segDifficulty = document.getElementById('segDifficulty'), segMode = document.getElementById('segMode');
  const voiceSelect = document.getElementById('voiceSelect');

  const autoNextBtn = document.getElementById('autoNextBtn');

  // state
  let wordPool = [];
  let queues = { easy:[], advanced:[], proficient:[] };
  let currentWord = null;
  let lastSubmitted = null;
  let roundStart = 0;
  let attemptsThisRound = [];
  let segEls = [];
  let roundEnded = false;
  let totalScore = 0;
  let autoNextTimer = null;

  // replay tracking for hardcore mode
  let replayCount = 0;
  const HARDCORE_MAX_REPLAYS = 3;

  let stats = JSON.parse(localStorage.getItem('spelling_stats') || '[]');
  const defaultSettings = { autoNext:false, difficulty:'proficient', mode:'normal', voice:'' };
  let settings = Object.assign({}, defaultSettings, JSON.parse(localStorage.getItem('spelling_settings') || '{}'));

  // colors
  const COLOR_NEUTRAL = getComputedStyle(document.documentElement).getPropertyValue('--muted').trim() || '#cfcfcf';
  const COLOR_GREEN = getComputedStyle(document.documentElement).getPropertyValue('--accent-green').trim() || '#4CAF50';
  const COLOR_YELLOW = getComputedStyle(document.documentElement).getPropertyValue('--accent-yellow').trim() || '#FFC107';
  const COLOR_RED = getComputedStyle(document.documentElement).getPropertyValue('--accent-red').trim() || '#F44336';

  // tooltip
  let miniTooltip = null;
  function showMiniTooltip(x,y,text,bg,txtColor='#fff'){
    hideMiniTooltip();
    miniTooltip = document.createElement('div'); miniTooltip.className = 'mini-tooltip';
    miniTooltip.style.background = bg; miniTooltip.style.color = txtColor; miniTooltip.textContent = text;
    document.body.appendChild(miniTooltip);
    const r = miniTooltip.getBoundingClientRect();
    // clamp horizontally and flip if near top
    let left = Math.max(6, Math.min(window.innerWidth - r.width - 6, x - r.width/2));
    let top = y - r.height - 10;
    if (top < 6) top = y + 14;
    miniTooltip.style.left = left + 'px';
    miniTooltip.style.top = top + 'px';
    requestAnimationFrame(()=>{ miniTooltip.style.opacity = 1; miniTooltip.style.transform = 'translateY(0)'; });
  }
  function hideMiniTooltip(){ if (miniTooltip){ miniTooltip.remove(); miniTooltip = null; } }

  function persistSettings(){ localStorage.setItem('spelling_settings', JSON.stringify(settings)); }
  function persistStats(){ localStorage.setItem('spelling_stats', JSON.stringify(stats)); }

  function capitalize(s){ return (!s)?s:s[0].toUpperCase()+s.slice(1); }
  function shuffle(a){ for (let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]]; } return a; }
  function escapeHtml(s){ return String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }

  // --- Robust loader: try wordslist.json, words.json, fallback to embedded ---
  async function loadWords(){
    wordPool = [];
    async function tryFetch(name){
      try {
        const res = await fetch(name, { cache: 'no-store' });
        const text = await res.text();
        try { return JSON.parse(text); } catch(e){ console.warn(`${name} fetched but invalid JSON.`); return null; }
      } catch(e){ return null; }
    }

    // only try network fetch when not file:// (CORS tripping). If file://, skip fetch to avoid errors.
    if (location.protocol !== 'file:') {
      let json = await tryFetch('wordslist.json');
      if (!json) json = await tryFetch('words.json');
      if (json){
        let arr = Array.isArray(json) ? json : (Array.isArray(json.words) ? json.words : []);
        arr = arr.map(it => {
          if (!it) return null;
          if (typeof it === 'string') return { word: it.toLowerCase(), level: 'easy' };
          const w = it.word ? String(it.word).toLowerCase() : null;
          const level = it.level ? String(it.level).toLowerCase() : 'easy';
          if (!w) return null;
          return { word: w, level };
        }).filter(Boolean);
        if (arr.length) {
          wordPool = arr;
          console.info('Loaded external word list:', wordPool.length, 'words');
        }
      }
    }

    // fallback to embedded
    if (!wordPool.length){
      try {
        const embedded = JSON.parse(document.getElementById('embeddedWords').textContent);
        const arr = (Array.isArray(embedded) ? embedded : embedded.words) || [];
        wordPool = arr.map(it => {
          if (!it) return null;
          if (typeof it === 'string') return { word: it.toLowerCase(), level: 'easy' };
          const w = it.word ? String(it.word).toLowerCase() : null;
          const level = it.level ? String(it.level).toLowerCase() : 'easy';
          if (!w) return null;
          return { word: w, level };
        }).filter(Boolean);
        console.info('Using embedded word list, count:', wordPool.length);
      } catch(e){
        console.warn('Embedded words parse failed; loading tiny fallback.');
        wordPool = [{word:'genuine',level:'easy'},{word:'resilient',level:'advanced'},{word:'ubiquitous',level:'proficient'}];
      }
    }

    // build per-level queues
    ['easy','advanced','proficient'].forEach(l=>{
      const arr = wordPool.filter(w => w.level === l).slice();
      queues[l] = shuffle(arr);
    });
  }

  function pickWordForDifficulty(level){
    level = (level || 'proficient').toLowerCase();
    if (!queues[level] || !queues[level].length){
      const refill = wordPool.filter(w => w.level === level).slice();
      queues[level] = shuffle(refill);
    }
    const item = (queues[level] && queues[level].shift()) || wordPool.find(w=>w.level===level) || wordPool[0];
    return (item && item.word) ? item.word : 'genuine';
  }

  // segments
  function renderSegments(){
    feedbackBar.innerHTML = '';
    let segCount = 3;
    if (settings.mode === 'easy') segCount = 5;
    else if (settings.mode === 'hardcore') segCount = 1;
    for (let i=0;i<segCount;i++){
      const d = document.createElement('div');
      d.className = 'segment';
      d.style.background = COLOR_NEUTRAL;
      d.dataset.index = i;
      feedbackBar.appendChild(d);
    }
    feedbackBar.appendChild(mergedBar);
    segEls = Array.from(feedbackBar.querySelectorAll('.segment'));
    mergedBar.style.opacity = 0; mergedBar.style.left='0px'; mergedBar.style.width='0px';
  }
  function resetSegments(){ segEls.forEach(s => { s.style.background = COLOR_NEUTRAL; s.style.visibility='visible'; }); mergedBar.style.opacity=0; mergedBar.style.left='0px'; mergedBar.style.width='0px'; }
  function colorSegment(i,color){ if (i<0||i>=segEls.length) return; segEls[i].style.background = color; }
  function colorAllSegments(color){ segEls.forEach(s => s.style.background = color); }

  // levenshtein
  function levenshtein(a,b){
    a=a||''; b=b||''; const al=a.length, bl=b.length; if (!al) return bl; if (!bl) return al;
    const dp = Array(al+1).fill(null).map(()=>Array(bl+1).fill(0));
    for (let i=0;i<=al;i++) dp[i][0]=i;
    for (let j=0;j<=bl;j++) dp[0][j]=j;
    for (let i=1;i<=al;i++) for (let j=1;j<=bl;j++){ const cost = a[i-1]===b[j-1]?0:1; dp[i][j]=Math.min(dp[i-1][j]+1, dp[i][j-1]+1, dp[i-1][j-1]+cost); }
    return dp[al][bl];
  }
  function similarityRatio(a,b){ if(!a&&!b) return 1; const d=levenshtein(a||'',b||''); return 1 - d/Math.max((a||'').length,(b||'').length||1); }

  function complexityInfo(w){ const len=(w||'').length; if (len<6) return {label:'Easy', mult:1.0}; if (len<=9) return {label:'Advanced', mult:1.25}; return {label:'Proficient', mult:1.5}; }
  function computePoints(correctnessScore, word, seconds){ const comp = complexityInfo(word).mult; const timeBonus = Math.max(0.5, Math.min(1.5, 5/Math.max(seconds,0.2))); return Math.round(10 * correctnessScore * comp * timeBonus); }

// Mode score multiplier: easy = 0.5x, normal = 1x, hardcore = 2x
  function getModeScoreMultiplier(){
    if (settings.mode === 'easy') return 0.5;
    if (settings.mode === 'hardcore') return 2.0;
    return 1.0;
  }

  function showFloating(points, type){
    const comboEl = document.getElementById('combo');
    if (!comboEl) return;
    comboEl.textContent = (points>0 ? `+${points} pts` : '+0 pts');
    comboEl.style.background = (type==='green'?COLOR_GREEN : type==='yellow'?COLOR_YELLOW : COLOR_RED);
    comboEl.classList.remove('show'); void comboEl.offsetWidth; comboEl.classList.add('show');
    setTimeout(()=>{ comboEl.classList.remove('show'); comboEl.style.background = ''; }, 1000);
  }

  // speak using selected voice (and count replays)
  function speak(word){
    if (!word) return;
    // block when hardcore and replayCount exceeded
    if (settings.mode === 'hardcore' && replayCount >= HARDCORE_MAX_REPLAYS){
      if (btnPlay) btnPlay.disabled = true;
      return;
    }
    const u = new SpeechSynthesisUtterance(word);
    if (settings.voice){
      const v = speechSynthesis.getVoices().find(x => x.name === settings.voice);
      if (v) u.voice = v;
    }
    u.rate = 0.95;
    speechSynthesis.cancel();
    speechSynthesis.speak(u);
  }

  function mergeRemainingIntoGreen(usedCount){
    if (!segEls.length) return;
    const barRect = feedbackBar.getBoundingClientRect();
    const firstRemaining = Math.min(usedCount, segEls.length-1);
    const remain = Math.max(1, segEls.length - usedCount);
    const startSeg = segEls[firstRemaining].getBoundingClientRect();
    const endIndex = Math.min(segEls.length-1, firstRemaining + remain - 1);
    const endSeg = segEls[endIndex].getBoundingClientRect();
    const left = startSeg.left - barRect.left;
    const right = endSeg.right - barRect.left;
    const width = Math.max(8, right - left);
    mergedBar.style.left = `${left}px`; mergedBar.style.width = `${width}px`; mergedBar.style.opacity = 1;
    for (let i = firstRemaining; i <= endIndex; i++) segEls[i].style.background = 'transparent';
  }

  function updateRevealHint(){
    if (settings.mode !== 'easy' || !currentWord){ hintLine.textContent = ''; return; }
    const total = 5;
    const usedWrong = attemptsThisRound.filter(a => a.outcome !== 'correct').length;
    const revealPercent = Math.min(100, Math.ceil((usedWrong / total) * 100));
    const lettersToReveal = Math.floor((revealPercent / 100) * currentWord.length);
    const visible = currentWord.slice(0, lettersToReveal);
    const hidden = currentWord.slice(lettersToReveal);
    if (lettersToReveal >= currentWord.length){
      hintLine.innerHTML = `<span style="color:${COLOR_GREEN};opacity:1">${escapeHtml(currentWord)}</span>`;
    } else {
      hintLine.innerHTML = `<span style="color:#888">${escapeHtml(visible)}</span><span style="color:#bbb">${'•'.repeat(Math.max(1, hidden.length))}</span>`;
    }
  }

  async function startNewRound(manual=false){
    if (manual && autoNextTimer){ clearTimeout(autoNextTimer); autoNextTimer = null; }

    // handle incomplete previous round (if there were attempts)
    if (!roundEnded && attemptsThisRound.length > 0){
      let best = 0; attemptsThisRound.forEach(a => { if (a.outcome === 'correct') best = Math.max(best, 1.0); else if (a.outcome === 'almost') best = Math.max(best, 0.6); });
      const used = attemptsThisRound.length;
      let multiplier = 0;
      if (settings.mode === 'easy'){ const map = {1:0.5,2:0.3,3:0.2,4:0.1}; multiplier = map[used] || 0; }
      else { multiplier = (used === 1 ? 0.3 : (used === 2 ? 0.1 : 0)); }
      const secs = Math.max(0.01, (performance.now() - roundStart) / 1000);
      const basePts = computePoints(best, currentWord, secs);
      const modeMult = getModeScoreMultiplier();
      const awarded = Math.round(basePts * multiplier * modeMult);
      if (awarded > 0){ totalScore += awarded; updateScore(); showFloating(awarded, best===1 ? 'green' : (best>=0.6 ? 'yellow' : 'red')); }
      stats.push({ word: currentWord, attempts: attemptsThisRound.slice(), level: complexityInfo(currentWord).label, time: secs, points: awarded, correct: best===1, incomplete:true, mode: settings.mode });
      persistStats();
    }

    lastSubmitted = null; attemptsThisRound = []; roundEnded = false;
    renderSegments(); resetSegments();
    inputAnswer.value = ''; inputAnswer.disabled = false; btnCheck.disabled = false;
    hintLine.textContent = '';

    // reset replay count & play button enable
    replayCount = 0;
    if (btnPlay){ btnPlay.disabled = false; }

    const level = settings.difficulty || 'proficient';
    currentWord = pickWordForDifficulty(level);
    roundStart = performance.now();

    if (settings.mode === 'easy'){
      const reveal = Math.min(1, Math.ceil(currentWord.length * 0.05));
      hintLine.innerHTML = `<span style="color:#888">${escapeHtml(currentWord.slice(0,reveal))}</span>${'•'.repeat(Math.max(1,currentWord.length-reveal))}`;
    } else {
      hintLine.textContent = '';
    }

    // automatic initial spoken audio (do not count towards hardcore replay limit)
    setTimeout(()=>{ 
      const u = new SpeechSynthesisUtterance(currentWord);
      if (settings.voice){
        const v = speechSynthesis.getVoices().find(x => x.name === settings.voice);
        if (v) u.voice = v;
      }
      u.rate = 0.95;
      speechSynthesis.cancel();
      speechSynthesis.speak(u);
      // we intentionally do NOT set result text here
    }, 320);
    setTimeout(()=> inputAnswer.focus(), 700);
  }

  function easyAttemptMultiplier(idx){ return ({1:1.0,2:0.8,3:0.6,4:0.4,5:0.2})[idx] || 0; }

  function onCheck(){
    if (!currentWord) return;
    const raw = (inputAnswer.value || '').trim().toLowerCase();
    if (!raw) return;

    if (lastSubmitted !== null && raw === lastSubmitted){
      inputAnswer.animate([{transform:'translateX(0)'},{transform:'translateX(-6px)'},{transform:'translateX(6px)'},{transform:'translateX(0)'}], {duration:220});
      return;
    }
    lastSubmitted = raw;

    const exact = raw === currentWord;
    const sim = similarityRatio(raw, currentWord);
    let outcome = 'wrong', correctness = 0;
    if (exact){ outcome = 'correct'; correctness = 1.0; }
    else if (sim >= 0.75){ outcome = 'almost'; correctness = 0.6; }

    attemptsThisRound.push({ value: raw, outcome });

    const idx = attemptsThisRound.length - 1;
    if (outcome === 'correct'){
      const usedBefore = attemptsThisRound.length - 1;
      mergeRemainingIntoGreen(usedBefore);
    } else {
      colorSegment(idx, outcome === 'almost' ? COLOR_YELLOW : COLOR_RED);
      if (settings.mode === 'easy') inputAnswer.value = '';
    }

    if (settings.mode === 'easy') updateRevealHint();

    const secs = Math.max(0.01, (performance.now() - roundStart) / 1000);
    let pts = 0;
    const modeMult = getModeScoreMultiplier();
    if (outcome === 'correct'){
      if (settings.mode === 'easy'){
        const attemptNo = attemptsThisRound.length;
        const mult = easyAttemptMultiplier(attemptNo);
        pts = Math.round(computePoints(1.0, currentWord, secs) * mult * modeMult);
      } else {
        pts = Math.round(computePoints(1.0, currentWord, secs) * modeMult);
      }
      totalScore += pts; updateScore(); showFloating(pts, 'green');
    } else if (outcome === 'almost'){
      if (settings.mode === 'easy'){ pts = Math.round(computePoints(0.6, currentWord, secs) * easyAttemptMultiplier(attemptsThisRound.length) * modeMult); }
      else { pts = Math.round(computePoints(0.6, currentWord, secs) * modeMult); }
      totalScore += pts; updateScore(); showFloating(pts, 'yellow');
    } else {
      showFloating(0, 'red');
    }

    // endings per mode
    if (outcome === 'correct'){
      roundEnded = true; inputAnswer.disabled = true; btnCheck.disabled = true;
      // show the correct word in the result text (green)
      resultText.textContent = currentWord;
      resultText.style.color = COLOR_GREEN;
      stats.push({ word: currentWord, attempts: attemptsThisRound.slice(), level: complexityInfo(currentWord).label, time: secs, points: pts, correct:true, incomplete:false, mode: settings.mode });
      persistStats();
      if (settings.autoNext){
        if (autoNextTimer) clearTimeout(autoNextTimer);
        autoNextTimer = setTimeout(()=>{ startNewRound(false); autoNextTimer = null; }, 3000);
      }
    } else {
      const maxAttempts = settings.mode === 'easy' ? 5 : (settings.mode === 'hardcore' ? 1 : 3);
      if (attemptsThisRound.length >= maxAttempts){
        roundEnded = true; inputAnswer.disabled = true; btnCheck.disabled = true;
        // show correct word in result box (red)
        resultText.textContent = currentWord;
        resultText.style.color = COLOR_RED;
        colorAllSegments(COLOR_RED);
        stats.push({ word: currentWord, attempts: attemptsThisRound.slice(), level: complexityInfo(currentWord).label, time: secs, points: 0, correct:false, incomplete:false, mode: settings.mode });
        persistStats();
        if (settings.autoNext){ if (autoNextTimer) clearTimeout(autoNextTimer); autoNextTimer = setTimeout(()=>{ startNewRound(false); autoNextTimer = null; }, 3000); }
      } else {
        if (settings.mode !== 'hardcore') {
          inputAnswer.value = ''; inputAnswer.focus();
        } else {
          // hardcore: only 1 attempt allowed -> disable input
          inputAnswer.value = ''; inputAnswer.disabled = true; btnCheck.disabled = true;
        }
      }
    }
  }

  // Stats rendering
  function renderStats(){
    statsList.innerHTML = '';
    const total = stats.length;
    const correct = stats.filter(s => s.correct).length;
    const acc = total ? Math.round(1000*(correct/total))/10 : 0;
    statsSummary.textContent = `Total: ${total} | Accuracy: ${acc}%`;

    stats.slice().reverse().forEach(s=>{
      const row = document.createElement('div'); row.className = 'stat-row';
      const left = document.createElement('div'); left.className = 'stat-left';
      const title = document.createElement('div'); title.textContent = s.word; title.style.fontWeight = '700';
      left.appendChild(title);
      if (s.mode === 'easy'){
        const icon = document.createElement('i'); icon.className = 'fa-solid fa-feather'; icon.style.color = '#7aa'; icon.style.fontSize = '14px';
        left.appendChild(icon);
      }
      const right = document.createElement('div'); right.className = 'stat-right';
      const segCount = (s.mode === 'easy') ? 5 : (s.mode === 'hardcore' ? 1 : 3);
      const mini = document.createElement('div'); mini.className = 'mini-bar';
      for (let i=0;i<segCount;i++){
        const ms = document.createElement('div'); ms.className = 'mini-seg'; ms.style.background = COLOR_NEUTRAL;
        if (i < s.attempts.length){
          const a = s.attempts[i];
          if (a.outcome === 'correct') ms.style.background = COLOR_GREEN;
          else if (a.outcome === 'almost') ms.style.background = COLOR_YELLOW;
          else ms.style.background = COLOR_RED;
          // unified hover + tap handler that works on mobile (taps)
          ms.addEventListener('mouseenter', (ev)=>{
            if (window.matchMedia('(hover: hover)').matches){
              const r = ev.target.getBoundingClientRect();
              const text = `${capitalize(a.outcome)}: ${a.value}`;
              const bg = a.outcome === 'correct' ? COLOR_GREEN : (a.outcome === 'almost' ? COLOR_YELLOW : COLOR_RED);
              const txt = (a.outcome === 'almost' ? '#111' : '#fff');
              showMiniTooltip(r.left + r.width/2, r.top, text, bg, txt);
            }
          });
          ms.addEventListener('mouseleave', ()=>{
            if (window.matchMedia('(hover: hover)').matches) hideMiniTooltip();
          });

          ms.addEventListener('click', (ev)=>{
            if (!window.matchMedia('(hover: hover)').matches){
              ev.stopPropagation();
              const r = ev.target.getBoundingClientRect();
              const text = `${capitalize(a.outcome)}: ${a.value}`;
              const bg = a.outcome === 'correct' ? COLOR_GREEN : (a.outcome === 'almost' ? COLOR_YELLOW : COLOR_RED);
              const txt = (a.outcome === 'almost' ? '#111' : '#fff');
              const already = miniTooltip !== null;
              hideMiniTooltip();
              if (!already) showMiniTooltip(r.left + r.width/2, r.top, text, bg, txt);
            }
          });
        }
        mini.appendChild(ms);
      }
      const ptsBox = document.createElement('div'); ptsBox.style.minWidth = '64px'; ptsBox.style.textAlign = 'right'; ptsBox.style.fontWeight = '700';
      ptsBox.textContent = `${s.points} pts`;
      right.appendChild(mini); right.appendChild(ptsBox);
      row.appendChild(left); row.appendChild(right);
      statsList.appendChild(row);
    });
  }

  btnClearStats.addEventListener('click', ()=>{ if (!confirm('Are you sure you want to wipe your statistics? This cannot be undone.')) return; stats = []; persistStats(); renderStats(); });

  // Settings UI
  function renderSettings(){
    // difficulty buttons
    Array.from(segDifficulty.querySelectorAll('button')).forEach(b => b.classList.toggle('on', b.dataset.val === settings.difficulty));
    // mode buttons
    Array.from(segMode.querySelectorAll('button')).forEach(b => b.classList.toggle('on', b.dataset.val === settings.mode));
  }

  segDifficulty.addEventListener('click',(e)=>{ if (e.target.tagName!=='BUTTON') return; settings.difficulty = e.target.dataset.val; persistSettings(); renderSettings(); startNewRound(false); });

  // Tooltips for mode and difficulty (mobile-friendly)
  const modeTooltips = {
    easy: '5 attempts, progressive hints',
    normal: '3 attempts, no help',
    hardcore: '1 attempt, limited audio replays'
  };
  const difficultyTooltips = {
    easy: 'A1-A2 level words',
    advanced: 'B1-B2 level words',
    proficient: 'C1-C2 level words'
  };

  function attachTooltipHandlers(button, text){
    button.addEventListener('mouseenter',(e)=>{
      if (window.matchMedia('(hover: hover)').matches){
        const r = e.target.getBoundingClientRect();
        showMiniTooltip(r.left + r.width/2, r.top, text, '#444', '#fff');
      }
    });
    button.addEventListener('mouseleave',(e)=>{
      if (window.matchMedia('(hover: hover)').matches) hideMiniTooltip();
    });
    button.addEventListener('click',(e)=>{
      if (!window.matchMedia('(hover: hover)').matches){
        const r = e.target.getBoundingClientRect();
        const already = miniTooltip !== null;
        hideMiniTooltip();
        if (!already) showMiniTooltip(r.left + r.width/2, r.top, text, '#444', '#fff');
      }
    });
  }

  Array.from(segMode.querySelectorAll('button')).forEach(btn=>{
    attachTooltipHandlers(btn, modeTooltips[btn.dataset.val] || '');
    btn.addEventListener('click',(e)=>{ settings.mode = e.target.dataset.val; persistSettings(); renderSettings(); renderSegments(); startNewRound(false); });
  });
  Array.from(segDifficulty.querySelectorAll('button')).forEach(btn=>{
    attachTooltipHandlers(btn, difficultyTooltips[btn.dataset.val] || '');
  });

  // Auto next toggle (single game control only)
  function setAutoNext(enabled){
    settings.autoNext = !!enabled;
    persistSettings();
    if (autoNextBtn) {
      if (settings.autoNext) { autoNextBtn.classList.add('checked'); autoNextBtn.setAttribute('aria-pressed','true'); }
      else { autoNextBtn.classList.remove('checked'); autoNextBtn.setAttribute('aria-pressed','false'); }
    }
  }
  if (autoNextBtn) autoNextBtn.addEventListener('click', ()=> setAutoNext(!settings.autoNext));

  // TTS voice population
  function populateVoices(){
    const voices = speechSynthesis.getVoices();
    voiceSelect.innerHTML = '';
    if (!voices || !voices.length){
      const opt = document.createElement('option'); opt.value=''; opt.textContent='(Default browser voice)'; voiceSelect.appendChild(opt); return;
    }
    const fallbackOpt = document.createElement('option'); fallbackOpt.value=''; fallbackOpt.textContent='(Default browser voice)'; voiceSelect.appendChild(fallbackOpt);
    voices.forEach(v=>{
      const opt = document.createElement('option');
      opt.value = v.name;
      opt.textContent = `${v.name}${v.lang ? ' — '+v.lang : ''}${v.default ? ' (default)' : ''}`;
      voiceSelect.appendChild(opt);
    });
    if (settings.voice) {
      const match = Array.from(voiceSelect.options).find(o => o.value === settings.voice);
      if (match) voiceSelect.value = settings.voice;
    }
  }
  speechSynthesis.addEventListener('voiceschanged', populateVoices);
  voiceSelect.addEventListener('change', ()=> { settings.voice = voiceSelect.value || ''; persistSettings(); });

  // Utility UI helpers
  function updateScore(){ scoreText.textContent = `Score: ${totalScore}`; }

  // Play button handler - counts user replay attempts in hardcore mode
  btnPlay.addEventListener('click', ()=>{
    if (!currentWord) { return; }
    // For hardcore, block after HARDCORE_MAX_REPLAYS
    if (settings.mode === 'hardcore'){
      if (replayCount >= HARDCORE_MAX_REPLAYS){
        btnPlay.disabled = true;
        return;
      }
      // user-initiated replay increments count
      replayCount++;
      if (replayCount >= HARDCORE_MAX_REPLAYS){
        // disable immediately to reflect block
        btnPlay.disabled = true;
      }
    }
    // speak
    const u = new SpeechSynthesisUtterance(currentWord);
    if (settings.voice){
      const v = speechSynthesis.getVoices().find(x => x.name === settings.voice);
      if (v) u.voice = v;
    }
    u.rate = 0.95;
    speechSynthesis.cancel();
    speechSynthesis.speak(u);
  });

  btnNext.addEventListener('click', ()=>{ if (autoNextTimer){ clearTimeout(autoNextTimer); autoNextTimer = null; } startNewRound(true); });
  btnCheck.addEventListener('click', onCheck);
  inputAnswer.addEventListener('keydown', (e)=>{ if (e.key === 'Enter'){ e.preventDefault(); onCheck(); } });

  // Tabs
  tabGame.addEventListener('click', ()=>{ pageGame.style.display=''; pageStats.style.display='none'; pageSettings.style.display='none'; tabGame.classList.add('active'); tabStats.classList.remove('active'); tabSettings.classList.remove('active'); });
  tabStats.addEventListener('click', ()=>{ pageStats.style.display=''; pageGame.style.display='none'; pageSettings.style.display='none'; tabStats.classList.add('active'); tabGame.classList.remove('active'); tabSettings.classList.remove('active'); renderStats(); });
  tabSettings.addEventListener('click', ()=>{ pageSettings.style.display=''; pageGame.style.display='none'; pageStats.style.display='none'; tabSettings.classList.add('active'); tabGame.classList.remove('active'); tabStats.classList.remove('active'); renderSettings(); });

  // Init
  (async function init(){
    await loadWords();
    renderSegments();
    renderSettings();
    renderStats();
    updateScore();
    populateVoices();
    setTimeout(populateVoices,600);
    setAutoNext(!!settings.autoNext);
    startNewRound(false);
  })();

  // persist
  window.addEventListener('beforeunload', ()=>{ persistSettings(); persistStats(); });

  // global click to close tooltip
  document.addEventListener('click',(e)=>{ if (miniTooltip && !miniTooltip.contains(e.target)) hideMiniTooltip(); });

})();
</script>
</body>
</html>
