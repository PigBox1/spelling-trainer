<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Spelling Trainer</title>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" crossorigin="anonymous" referrerpolicy="no-referrer"/>
<style>
:root {
  --page-bg: #eceff1;
  --card-bg: #ffffff;
  --muted: #cfcfcf;
  --muted-2: #bfbfbf;
  --accent-green: #4CAF50;
  --accent-yellow: #FFC107;
  --accent-red: #F44336;
  --card-width: 760px;
  --shadow: 0 10px 30px rgba(20,20,30,0.06);
  --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, "Roboto Mono", "Courier New", monospace;

  /* Unified UI metrics */
  --ui-radius: 8px;
  --ui-border: 2px;
  --main-icon-size: 48px;
}

/* --- Base Layout --- */
html, body {
  height: 100%;
  margin: 0;
  font-family: system-ui, -apple-system, "Segoe UI", Roboto, Arial;
  background: var(--page-bg);
  color: #222;
}

.wrap {
  min-height: 100%;
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 28px;
}

.card {
  width: 100%;
  max-width: var(--card-width);
  background: var(--card-bg);
  border-radius: var(--ui-radius);
  box-shadow: var(--shadow);
  padding: 20px 22px; /* ALIGNMENT FIX: slightly increased right padding */
  box-sizing: border-box;
}

/* --- Header & Navigation --- */
header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 12px;
  box-sizing: border-box; /* ALIGNMENT FIX */
  width: 100%;            /* ALIGNMENT FIX */
}

header h1 {
  font-size: 18px;
  margin: 0;
}

nav {
  display: flex;
  gap: 8px;
}

/* Transparent tab style to match new vibe */
nav button {
  background: transparent;
  border: var(--ui-border) solid var(--muted-2);
  border-radius: var(--ui-radius);
  color: var(--muted-2);
  font-weight: 700;
  padding: 8px 14px;
  cursor: pointer;
  transition: all 0.25s ease;
  height: 38px; /* ALIGNMENT FIX: aligns with input and score box */
  display: flex; /* ALIGNMENT FIX */
  align-items: center; /* ALIGNMENT FIX */
  justify-content: center; /* ALIGNMENT FIX */
}

nav button:hover {
  background: rgba(0,0,0,0.03);
  color: #111;
}

nav button.active {
  border-color: var(--accent-green);
  color: var(--accent-green);
  background: rgba(76,175,80,0.08);
}

/* --- Input Fields --- */
input.word-input {
  flex: 1;
  height: var(--main-icon-size);
  border-radius: var(--ui-radius);
  border: var(--ui-border) solid var(--muted-2);
  font-size: 16px;
  background: transparent;
  color: #111;
  padding: 0 16px;
  box-sizing: border-box;
  min-width: 350px;
  transition: all 0.25s ease;
}

input.word-input:focus {
  outline: none;
  border-color: var(--muted-2);
}

/* --- Universal Button Reset --- */
button,
.icon-btn,
.btn-play,
.auto-btn,
.segmented button,
.stats-wipe-btn {
  border-radius: var(--ui-radius);
  border: var(--ui-border) solid var(--muted-2);
  background: transparent;
  color: var(--muted-2);
  cursor: pointer;
  transition: all 0.25s ease;
}

/* --- Icon Buttons (Main Game Controls) --- */
.btn-play,
.icon-btn,
.auto-btn {
  width: var(--main-icon-size);
  height: var(--main-icon-size);
  padding: 0;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  box-sizing: border-box;
}

.btn-play i,
.icon-btn i,
.auto-btn i,
.stats-wipe-btn i {
  font-size: 18px;
  color: inherit;
  line-height: 1;
  transition: transform 0.15s ease, color 0.15s ease;
}
  
button:hover,
.icon-btn:hover,
.btn-play:hover,
.segmented button:hover,
.stats-wipe-btn:hover {
  background: rgba(0,0,0,0.03);
}

/* Slight pressed feedback */
button:active,
.icon-btn:active,
.btn-play:active {
  background: rgba(0,0,0,0.08);
}

.auto-btn:hover {
  background: rgba(0, 0, 0, 0.03);
  transform: scale(1.05);
}

.auto-btn.checked {
  border-color: var(--accent-green);
  color: var(--accent-green);
  background: rgba(76, 175, 80, 0.1);
}
  
button:active,
.icon-btn:active,
.btn-play:active {
  background: rgba(0,0,0,0.08);
}

button[disabled],
.icon-btn[disabled],
.btn-play[disabled],
.auto-btn[disabled] {
  opacity: 0.5;
  cursor: not-allowed;
}

/* --- Toggle / Active States --- */
.segmented button.on {
  border-color: var(--accent-green);
  color: var(--accent-green);
  background: transparent;
}

/* Difficulty colors — outline only */
.segmented button[data-val="easy"].on {
  border-color: var(--accent-green);
  color: var(--accent-green);
  background: transparent;
}

.segmented button[data-val="advanced"].on {
  border-color: var(--accent-yellow);
  color: var(--accent-yellow);
  background: transparent;
}

.segmented button[data-val="proficient"].on {
  border-color: var(--accent-red);
  color: var(--accent-red);
  background: transparent;
}

/* Mode colors — outline only */
.segmented button[data-val="easy"].on[data-group="mode"] {
  border-color: var(--accent-green);
  color: var(--accent-green);
  background: transparent;
}

.segmented button[data-val="normal"].on {
  border-color: var(--accent-yellow);
  color: var(--accent-yellow);
  background: transparent;
}

.segmented button[data-val="hardcore"].on {
  border-color: var(--accent-red);
  color: var(--accent-red);
  background: transparent;
}

/* Auto Next toggle */
.auto-btn.checked {
  border-color: var(--accent-green);
  color: var(--accent-green);
  background: rgba(76,175,80,0.08);
}

/* --- Wipe Button (transparent idle, grey outline, red hover) --- */
.stats-wipe-btn {
  width: 44px;
  height: 44px;
  padding: 0;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  border: var(--ui-border) solid var(--muted-2) !important;
  border-radius: var(--ui-radius) !important;
  background: transparent !important;
  color: var(--muted-2) !important;
  cursor: pointer;
  box-shadow: none !important;
  transition: border-color 0.18s ease, color 0.18s ease, transform 0.12s ease;
}

.stats-wipe-btn i {
  font-size: 18px;
  color: currentColor !important;
  line-height: 1;
  transition: color 0.15s ease, transform 0.12s ease;
}

.stats-wipe-btn:hover,
.stats-wipe-btn:focus,
.stats-wipe-btn:focus-visible {
  background: transparent !important;
  border-color: var(--accent-red) !important;
  color: var(--accent-red) !important;
  outline: none !important;
  box-shadow: none !important;
}

.stats-wipe-btn:hover i { transform: scale(1.08); }
.stats-wipe-btn:active i { transform: scale(1); }

.stats-wipe-btn > i[style] { color: currentColor !important; }

/* --- Hint / Result --- */
.result {
  font-weight: 700;
  color: #444;
  flex: 1;
  max-width: 100px;
  text-align: right;
}

/* the hintLine below is repurposed to contain the definition after the round ends */
.hint-line {
  margin-top: 8px;
  font-family: inherit;
  color: #666;
  text-align: left;
  min-height: 28px;
  transition: opacity 0.25s ease;
  font-style: italic;
}

/* --- Feedback Bars --- */
.feedback-wrap {
  width: 100%;
  display: flex;
  justify-content: center;
  margin-top: 8px;
}

.feedback-bar {
  width: 100%;
  display: flex;
  gap: 10px;
  position: relative;
  align-items: center;
  padding: 6px 0;
}

.segment {
  flex: 1;
  height: 14px;
  background: var(--muted);
  border-radius: var(--ui-radius);
  transition: background 0.22s ease, flex 0.22s ease, width 0.22s ease;
  position: relative;
}

.merged {
  position: absolute;
  height: 14px;
  background: var(--accent-green);
  border-radius: var(--ui-radius);
  transition: left 0.22s ease, width 0.22s ease, opacity 0.22s ease;
  opacity: 0;
  pointer-events: none;
}

/* --- Controls --- */
.controls {
  display: flex;
  gap: 10px;
  margin-top: 12px;
  align-items: center;
  box-sizing: border-box; /* ALIGNMENT FIX */
  width: 100%;            /* ALIGNMENT FIX */
}

/* --- Score box --- */
.score-box {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  gap: 8px;
  height: var(--main-icon-size);
  min-width: 88px;
  padding: 0 16px;
  border: var(--ui-border) solid var(--muted-2);
  border-radius: var(--ui-radius);
  background: transparent;
  color: #111;
  font-size: 16px;
  font-weight: 500;
  box-sizing: border-box;
}

/* make icon match outline color */
.score-box i {
  font-size: 14px;
  color: var(--muted-2);
  line-height: 1;
}

/* value styling */
#scoreValue {
  font-size: 16px;
  white-space: nowrap;
  color: inherit;
}

/* subtle hover feedback */
.score-box:hover {
  background: rgba(0,0,0,0.02);
}

/* --- Segmented Controls --- */
.segmented {
  display: flex;
  gap: 12px;
  border-radius: var(--ui-radius);
  padding: 0;
  background: transparent;
  align-items: center;
  flex-wrap: nowrap;
  box-sizing: border-box;
  margin: 0;
}

.segmented button {
  flex: 0 0 auto;
  border: var(--ui-border) solid var(--muted-2);
  border-radius: var(--ui-radius);
  color: #666;
  font-weight: 700;
  padding: 8px 14px;
  background: transparent;
  white-space: nowrap;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  box-sizing: border-box;
}

/* --- Settings Rows --- */
.settings-row {
  display: flex;
  gap: 16px;
  align-items: center;
  padding: 10px 0;
  box-sizing: border-box;
}
  
.label {
  width: 120px;
  display: flex;
  align-items: center;
  font-size: 14px;
  color: #666;
  white-space: nowrap;
  box-sizing: border-box;
  padding-left: 4px;
}

.control {
  flex: 1;
  display: flex;
  align-items: center;
  gap: 12px;
  box-sizing: border-box;
}

/* --- Select --- */
.select {
  padding: 10px 12px;
  border-radius: var(--ui-radius);
  border: var(--ui-border) solid var(--muted-2);
  background: transparent;
  font-size: 14px;
  width: 100%;
  box-sizing: border-box;
  color: #111;
  transition: all 0.25s ease;
}

.select:focus {
  border-color: var(--accent-green);
  outline: none;
}

/* --- Stats Section --- */
.stats-list {
  display: flex;
  flex-direction: column;
  gap: 8px;
  margin-top: 8px;
}

.stat-row {
  display: flex;
  gap: 12px;
  align-items: center;
  justify-content: space-between;
  padding: 8px;
  border-radius: var(--ui-radius);
  background: #fbfbfb;
  border: var(--ui-border) solid #f0f0f0;
}

.stat-left {
  display: flex;
  align-items: center;
  gap: 8px;
  flex: 1;
  font-weight: 600;
}

.stat-right {
  display: flex;
  align-items: center;
  gap: 12px;
  width: 300px;
  justify-content: flex-end;
}

/* --- Mini Stats Bars --- */
.mini-bar {
  display: flex;
  gap: 6px;
  width: 180px;
  height: 12px;
  align-items: center;
  position: relative;
}

.mini-seg {
  flex: 1;
  height: 100%;
  border-radius: var(--ui-radius);
  background: var(--muted);
  position: relative;
  transition: background 0.18s ease;
}

/* --- Tooltip --- */
.mini-tooltip {
  position: fixed;
  z-index: 9999;
  padding: 6px 8px;
  border-radius: 6px;
  color: #fff;
  font-weight: 700;
  font-size: 12px;
  white-space: pre-line;
  pointer-events: none;
  transform: translateY(-6px);
  opacity: 0;
  transition: opacity 0.12s ease, transform 0.12s ease;
}

/* --- Misc --- */
.small {
  font-size: 13px;
  color: #666;
}

.play-row {
  display: flex;
  align-items: center;
  gap: 12px;
  margin-bottom: 20px;
  margin-left: -2px;
  margin-right: -2px; /* ALIGNMENT FIX: aligns textbox with nav & score box */
  box-sizing: border-box; /* ALIGNMENT FIX */
  width: 100%; /* ALIGNMENT FIX */
}

.play-row .btn-play {
  flex: 0 0 var(--main-icon-size);
}

.play-row input.word-input {
  flex: 1;
  min-width: 0;
  margin-right: 0; /* ALIGNMENT FIX */
  border-radius: var(--ui-radius);
  border: var(--ui-border) solid var(--muted-2);
  box-sizing: border-box;
}

.play-row .result {
  flex: 0 0 auto;
  max-width: 100px;
  text-align: right;
}

/* --- Responsive --- */
@media (max-width: 760px) {
  .card { padding: 14px; }
  .stat-right { width: 200px; }
  .label { min-width: 84px; }
  .result { font-size: 14px; text-align: center; }
  :root { --main-icon-size: 44px; }
  .btn-play i,
  .icon-btn i,
  .auto-btn i,
  .stats-wipe-btn i {
    font-size: 18px;
    line-height: 1;
    color: inherit;
    transition: transform 0.15s ease, color 0.15s ease;
  }
  .btn-play:hover i,
  .icon-btn:hover i,
  .auto-btn:hover i,
  .stats-wipe-btn:hover i {
    transform: scale(1.08);
  }
}
</style>

</head>
<body>
  <div class="wrap">
    <div class="card" role="application" aria-label="Spelling trainer">
      <header>
        <h1>Spelling Trainer</h1>
        <nav>
          <button id="tabGame" type="button" class="active">Game</button>
          <button id="tabStats" type="button">Stats</button>
          <button id="tabSettings" type="button">Settings</button>
        </nav>
      </header>

      <main>
        <!-- GAME -->
        <section id="pageGame">
          <div class="play-row" style="width:100%;">
            <button id="btnPlay" class="btn-play" title="Play"><i class="fa-solid fa-play" style="font-size:14px"></i></button>
            <input id="inputAnswer" class="word-input" placeholder="Type what you hear..." autocomplete="off" />
            <div class="result" id="resultText" aria-live="polite"></div>
          </div>

          <!-- reused to show definition once round ends -->
          <div class="hint-line" id="hintLine" aria-hidden="true"></div>

          <div class="feedback-wrap">
            <div class="feedback-bar" id="feedbackBar" aria-hidden="true">
              <div class="merged" id="mergedBar"></div>
            </div>
          </div>

<div class="controls">
  <button id="btnCheck" class="icon-btn" type="button" title="Check"><i class="fa-solid fa-square-check" aria-hidden="true"></i></button>
  <button id="btnNext" class="icon-btn" type="button" title="Next"><i class="fa-solid fa-forward" aria-hidden="true"></i></button>
  <button id="autoNextBtn" class="icon-btn auto-btn" type="button" aria-pressed="false" title="Auto Next"><i class="fa-solid fa-arrows-spin" aria-hidden="true"></i></button>

  <!-- spacer to push score box to the right -->
  <div style="flex:1"></div>

  <!-- Score box: number + diamond icon, same height as segmented/main controls -->
  <div class="score-box" id="scoreBox" title="Score" aria-live="polite" role="status" aria-atomic="true">
    <span id="scoreValue">0</span>
    <i class="fa-solid fa-diamond" aria-hidden="true" style="margin-left:8px"></i>
  </div>
</div>

        </section>

        <!-- STATS -->
        <section id="pageStats" style="display:none">
          <div style="display:flex;justify-content:space-between;align-items:center">
            <div class="small" id="statsSummary">Total: 0 | Accuracy: 0%</div>
            <div>
              <button id="btnClearStats" class="btn small stats-wipe-btn" type="button" title="Wipe statistics" aria-label="Wipe statistics">
                <i class="fa-solid fa-trash" aria-hidden="true"></i>
              </button>
            </div>
          </div>
          <div class="stats-list" id="statsList"></div>
        </section>

        <!-- SETTINGS -->
        <section id="pageSettings" style="display:none">
          <div style="display:flex;flex-direction:column;gap:12px">
            <div class="settings-row">
              <div class="label">Difficulty</div>
              <div class="control">
                <div class="segmented" id="segDifficulty">
                  <button data-val="easy" type="button">Easy</button>
                  <button data-val="advanced" type="button">Advanced</button>
                  <button data-val="proficient" type="button">Proficient</button>
                </div>
              </div>
            </div>

            <div class="settings-row">
              <div class="label">Mode</div>
              <div class="control">
                <div class="segmented" id="segMode">
                  <button data-val="easy" type="button">Easy</button>
                  <button data-val="normal" type="button">Normal</button>
                  <button data-val="hardcore" type="button">Hardcore</button>
                </div>
              </div>
            </div>

            <div class="settings-row">
              <div class="label">TTS Voice</div>
              <div class="control">
                <select id="voiceSelect" class="select" aria-label="Select TTS voice">
                  <option value="">Loading voices…</option>
                </select>
              </div>
            </div>

            <div class="settings-row">
              <div class="label">Definition</div>
              <div class="control">
                <div class="segmented" id="segDefinitionTiming">
                  <button data-val="before" type="button">Show before</button>
                  <button data-val="after" type="button">Show after</button>
                </div>
              </div>
            </div>


            <div class="small" style="color:#666; display: flex; flex-direction: column; gap: 6px;">
              <span>made with ❤️ (and chatgpt) by daniel</span>
              <span>using data from <a href="https://github.com/openlanguageprofiles/olp-en-cefrj" target="_blank" rel="noopener noreferrer">open language profiles</a></span>
            </div>

          </div>
        </section>
      </main>
    </div>
  </div>

<!-- embedded fallback words -->
<script id="embeddedWords" type="application/json">
{
  "words":[
    {"word":"abandon","level":"easy"},{"word":"bravery","level":"easy"},{"word":"elegant","level":"easy"},{"word":"harvest","level":"easy"},{"word":"journey","level":"easy"},
    {"word":"meticulous","level":"advanced"},{"word":"resilient","level":"advanced"},{"word":"transcendent","level":"advanced"},{"word":"alleviate","level":"advanced"},{"word":"benevolent","level":"advanced"},
    {"word":"juxtaposition","level":"proficient"},{"word":"idiosyncrasy","level":"proficient"},{"word":"ephemeral","level":"proficient"},{"word":"conscientious","level":"proficient"},{"word":"magnanimous","level":"proficient"}
  ]
}
</script>

<script>
(() => {
  // DOM
  const tabGame = document.getElementById('tabGame'), tabStats = document.getElementById('tabStats'), tabSettings = document.getElementById('tabSettings');
  const pageGame = document.getElementById('pageGame'), pageStats = document.getElementById('pageStats'), pageSettings = document.getElementById('pageSettings');

  const btnPlay = document.getElementById('btnPlay'), btnCheck = document.getElementById('btnCheck'), btnNext = document.getElementById('btnNext');
  const inputAnswer = document.getElementById('inputAnswer'), hintLine = document.getElementById('hintLine');
  const feedbackBar = document.getElementById('feedbackBar'), mergedBar = document.getElementById('mergedBar');
  const resultText = document.getElementById('resultText'), scoreText = document.getElementById('scoreText');

  const statsList = document.getElementById('statsList'), statsSummary = document.getElementById('statsSummary'), btnClearStats = document.getElementById('btnClearStats');
  const segDifficulty = document.getElementById('segDifficulty'), segMode = document.getElementById('segMode');
  const segDefinitionTiming = document.getElementById('segDefinitionTiming');
  const voiceSelect = document.getElementById('voiceSelect');

  const autoNextBtn = document.getElementById('autoNextBtn');

  // state
  let wordPool = [];
  let queues = { easy:[], advanced:[], proficient:[] };
  let currentWord = null;
  let lastSubmitted = null;
  let roundStart = 0;
  let attemptsThisRound = [];
  let segEls = [];
  let roundEnded = false;
  let totalScore = 0;
  let autoNextTimer = null;

  // definitions cache (persisted)
  let definitionsCache = {};
  try { definitionsCache = JSON.parse(localStorage.getItem('definition_cache') || '{}'); } catch(e){ definitionsCache = {}; }

  // replay tracking for hardcore mode
  let replayCount = 0;
  const HARDCORE_MAX_REPLAYS = 3;

  let stats = JSON.parse(localStorage.getItem('spelling_stats') || '[]');
  const defaultSettings = { autoNext:false, difficulty:'proficient', mode:'normal', voice:'', defTiming:'before' };
  let settings = Object.assign({}, defaultSettings, JSON.parse(localStorage.getItem('spelling_settings') || '{}'));

  // colors
  const COLOR_NEUTRAL = getComputedStyle(document.documentElement).getPropertyValue('--muted').trim() || '#cfcfcf';
  const COLOR_GREEN = getComputedStyle(document.documentElement).getPropertyValue('--accent-green').trim() || '#4CAF50';
  const COLOR_YELLOW = getComputedStyle(document.documentElement).getPropertyValue('--accent-yellow').trim() || '#FFC107';
  const COLOR_RED = getComputedStyle(document.documentElement).getPropertyValue('--accent-red').trim() || '#F44336';

  // tooltip
  let miniTooltip = null;
  function showMiniTooltip(x,y,text,bg,txtColor='#fff'){
    hideMiniTooltip();
    miniTooltip = document.createElement('div'); miniTooltip.className = 'mini-tooltip';
    miniTooltip.style.background = bg; miniTooltip.style.color = txtColor; miniTooltip.textContent = text;
    document.body.appendChild(miniTooltip);
    const r = miniTooltip.getBoundingClientRect();
    // clamp horizontally and flip if near top
    let left = Math.max(6, Math.min(window.innerWidth - r.width - 6, x - r.width/2));
    let top = y - r.height - 10;
    if (top < 6) top = y + 14;
    miniTooltip.style.left = left + 'px';
    miniTooltip.style.top = top + 'px';
    requestAnimationFrame(()=>{ miniTooltip.style.opacity = 1; miniTooltip.style.transform = 'translateY(0)'; });
  }
  function hideMiniTooltip(){ if (miniTooltip){ miniTooltip.remove(); miniTooltip = null; } }

  function persistSettings(){ localStorage.setItem('spelling_settings', JSON.stringify(settings)); }
  function persistStats(){ localStorage.setItem('spelling_stats', JSON.stringify(stats)); }
  function persistDefinitionsCache(){ try{ localStorage.setItem('definition_cache', JSON.stringify(definitionsCache)); } catch(e){ /* ignore storage errors */ } }

  function capitalize(s){ return (!s)?s:s[0].toUpperCase()+s.slice(1); }
  function shuffle(a){ for (let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]]; } return a; }
  function escapeHtml(s){ return String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }

  // --- Robust loader: try wordslist.json, words.json, fallback to embedded ---
  async function loadWords(){
    wordPool = [];
    // maps canonical -> [variant1, variant2, ...] (all normalized)
    window.variantsMap = window.variantsMap || {};
    // maps canonical -> original display string (e.g. "color/colour")
    window.displayMap = window.displayMap || {};

    function normalizeToken(s){
      if (!s) return '';
      return String(s).trim().toLowerCase().replace(/(^"|"$)/g,'').replace(/^\uFEFF/, '');
    }
    function extractVariantsFromField(field){
      // convert parentheses to slash for predictable splitting: "colour (color)" -> "colour/color"
      if (!field) return [];
      let s = String(field).trim();
      s = s.replace(/\(\s*([^)]+)\s*\)/g, '/$1');
      // split on slash or comma
      const parts = s.split(/\s*\/\s*|\s*,\s*/);
      const out = [];
      parts.forEach(p => {
        const t = normalizeToken(p).replace(/^[^a-z0-9']+|[^a-z0-9']+$/g,'');
        if (t && !out.includes(t)) out.push(t);
      });
      return out;
    }

    async function tryFetch(name){
      try {
        const res = await fetch(name, { cache: 'no-store' });
        const text = await res.text();
        try { return JSON.parse(text); } catch(e){ console.warn(`${name} fetched but invalid JSON.`); return null; }
      } catch(e){ return null; }
    }

    // attempt network fetch (skip when running file:// to avoid CORS errors)
    if (location.protocol !== 'file:') {
      let json = await tryFetch('wordslist.json');
      if (!json) json = await tryFetch('words.json');
      if (json && Array.isArray(json) && json.length){
        const expanded = [];
        // for each entry expected {word: "color/colour", level: "easy"}
        json.forEach(it => {
          if (!it || !it.word) return;
          const display = String(it.word).trim();
          const variants = extractVariantsFromField(display);
          if (!variants.length) return;
          const canonical = variants[0]; // first variant as canonical token (normalized)
          // store variants and displayMap
          if (!window.variantsMap[canonical]) window.variantsMap[canonical] = [];
          variants.forEach(v => {
            if (!window.variantsMap[canonical].includes(v)) window.variantsMap[canonical].push(v);
          });
          window.displayMap[canonical] = display;
          // push internal object (canonical internal word + level)
          expanded.push({ word: canonical, level: (it.level || 'easy').toLowerCase() });
        });
        if (expanded.length){
          wordPool = expanded;
          console.info('Loaded external word list:', wordPool.length, 'words; variants registered:', Object.keys(window.variantsMap).length);
        }
      }
    }

    // fallback to embedded script tag id="embeddedWords" if nothing loaded
    if (!wordPool.length){
      try {
        const embedded = JSON.parse(document.getElementById('embeddedWords').textContent);
        const arr = (Array.isArray(embedded) ? embedded : embedded.words) || [];
        const expanded = [];
        arr.forEach(it => {
          if (!it || !it.word) return;
          const display = String(it.word).trim();
          const variants = extractVariantsFromField(display);
          if (!variants.length) return;
          const canonical = variants[0];
          if (!window.variantsMap[canonical]) window.variantsMap[canonical] = [];
          variants.forEach(v => { if (!window.variantsMap[canonical].includes(v)) window.variantsMap[canonical].push(v); });
          window.displayMap[canonical] = display;
          expanded.push({ word: canonical, level: (it.level || 'easy').toLowerCase() });
        });
        if (expanded.length){
          wordPool = expanded;
          console.info('Using embedded word list, count:', wordPool.length);
        }
      } catch(e){
        console.warn('Embedded words parse failed; loading tiny fallback.');
        wordPool = [{word:'genuine',level:'easy'},{word:'resilient',level:'advanced'},{word:'ubiquitous',level:'proficient'}];
        window.variantsMap = window.variantsMap || {};
        window.displayMap = window.displayMap || {};
        wordPool.forEach(w => { window.variantsMap[w.word] = [w.word]; window.displayMap[w.word] = w.word; });
      }
    }

    // build per-level queues the same way you already did
    ['easy','advanced','proficient'].forEach(l=>{
      const arr = wordPool.filter(w => w.level === l).slice();
      queues[l] = shuffle(arr);
    });

    // ensure every canonical has at least itself in variantsMap & displayMap
    window.variantsMap = window.variantsMap || {};
    window.displayMap = window.displayMap || {};
    wordPool.forEach(w => {
      if (!window.variantsMap[w.word]) window.variantsMap[w.word] = [w.word];
      if (!window.displayMap[w.word]) window.displayMap[w.word] = w.word;
    });
  }

  function pickWordForDifficulty(level){
    level = (level || 'proficient').toLowerCase();
    if (!queues[level] || !queues[level].length){
      const refill = wordPool.filter(w => w.level === level).slice();
      queues[level] = shuffle(refill);
    }
    const item = (queues[level] && queues[level].shift()) || wordPool.find(w=>w.level===level) || wordPool[0];
    return (item && item.word) ? item.word : 'genuine';
  }

  // segments
  function renderSegments(){
    feedbackBar.innerHTML = '';
    let segCount = 3;
    if (settings.mode === 'easy') segCount = 5;
    else if (settings.mode === 'hardcore') segCount = 1;
    for (let i=0;i<segCount;i++){
      const d = document.createElement('div');
      d.className = 'segment';
      d.style.background = COLOR_NEUTRAL;
      d.dataset.index = i;
      feedbackBar.appendChild(d);
    }
    feedbackBar.appendChild(mergedBar);
    segEls = Array.from(feedbackBar.querySelectorAll('.segment'));
    mergedBar.style.opacity = 0; mergedBar.style.left='0px'; mergedBar.style.width='0px';
  }
  function resetSegments(){ segEls.forEach(s => { s.style.background = COLOR_NEUTRAL; s.style.visibility='visible'; }); mergedBar.style.opacity=0; mergedBar.style.left='0px'; mergedBar.style.width='0px'; }
  function colorSegment(i,color){ if (i<0||i>=segEls.length) return; segEls[i].style.background = color; }
  function colorAllSegments(color){ segEls.forEach(s => s.style.background = color); }

  // levenshtein
  function levenshtein(a,b){
    a=a||''; b=b||''; const al=a.length, bl=b.length; if (!al) return bl; if (!bl) return al;
    const dp = Array(al+1).fill(null).map(()=>Array(bl+1).fill(0));
    for (let i=0;i<=al;i++) dp[i][0]=i;
    for (let j=0;j<=bl;j++) dp[0][j]=j;
    for (let i=1;i<=al;i++) for (let j=1;j<=bl;j++){ const cost = a[i-1]===b[j-1]?0:1; dp[i][j]=Math.min(dp[i-1][j]+1, dp[i][j-1]+1, dp[i-1][j-1]+cost); }
    return dp[al][bl];
  }
  function similarityRatio(a,b){ if(!a&&!b) return 1; const d=levenshtein(a||'',b||''); return 1 - d/Math.max((a||'').length,(b||'').length||1); }

  function complexityInfo(w){ const len=(w||'').length; if (len<6) return {label:'Easy', mult:1.0}; if (len<=9) return {label:'Advanced', mult:1.25}; return {label:'Proficient', mult:1.5}; }
  function computePoints(correctnessScore, word, seconds){ const comp = complexityInfo(word).mult; const timeBonus = Math.max(0.5, Math.min(1.5, 5/Math.max(seconds,0.2))); return Math.round(10 * correctnessScore * comp * timeBonus); }

// Mode score multiplier: easy = 0.5x, normal = 1x, hardcore = 2x
  function getModeScoreMultiplier(){
    if (settings.mode === 'easy') return 0.5;
    if (settings.mode === 'hardcore') return 2.0;
    return 1.0;
  }

// When definitions are hidden until AFTER the guess, award a 1.25x multiplier.
  function getDefinitionTimingMultiplier(){
    return (settings.defTiming === 'after') ? 1.25 : 1.0;
  }
  
  function showFloating(points, type){
    const comboEl = document.getElementById('combo');
    if (!comboEl) return;
    comboEl.textContent = (points>0 ? `+${points} pts` : '+0 pts');
    comboEl.style.background = (type==='green'?COLOR_GREEN : type==='yellow'?COLOR_YELLOW : COLOR_RED);
    comboEl.classList.remove('show'); void comboEl.offsetWidth; comboEl.classList.add('show');
    setTimeout(()=>{ comboEl.classList.remove('show'); comboEl.style.background = ''; }, 1000);
  }

  // speak using selected voice (and count replays)
  function speak(word){
    if (!word) return;
    // block when hardcore and replayCount exceeded
    if (settings.mode === 'hardcore' && replayCount >= HARDCORE_MAX_REPLAYS){
      if (btnPlay) btnPlay.disabled = true;
      return;
    }
    const u = new SpeechSynthesisUtterance(word);
    if (settings.voice){
      const v = speechSynthesis.getVoices().find(x => x.name === settings.voice);
      if (v) u.voice = v;
    }
    u.rate = 0.95;
    speechSynthesis.cancel();
    speechSynthesis.speak(u);
  }

  function mergeRemainingIntoGreen(usedCount){
    if (!segEls.length) return;
    const barRect = feedbackBar.getBoundingClientRect();
    const firstRemaining = Math.min(usedCount, segEls.length-1);
    const remain = Math.max(1, segEls.length - usedCount);
    const startSeg = segEls[firstRemaining].getBoundingClientRect();
    const endIndex = Math.min(segEls.length-1, firstRemaining + remain - 1);
    const endSeg = segEls[endIndex].getBoundingClientRect();
    const left = startSeg.left - barRect.left;
    const right = endSeg.right - barRect.left;
    const width = Math.max(8, right - left);
    mergedBar.style.left = `${left}px`; mergedBar.style.width = `${width}px`; mergedBar.style.opacity = 1;
    for (let i = firstRemaining; i <= endIndex; i++) segEls[i].style.background = 'transparent';
  }

  // updateRevealHint now writes into the input placeholder (for easy mode)
  function updateRevealHint(){
    if (settings.mode !== 'easy' || !currentWord){ 
      // reset placeholder to default when not easy
      inputAnswer.placeholder = 'Type what you hear...';
      return; 
    }
    const total = 5;
    const usedWrong = attemptsThisRound.filter(a => a.outcome !== 'correct').length;
    const revealPercent = Math.min(100, Math.ceil((usedWrong / total) * 100));
    // use canonical token length for reveal calculation (it's normalized)
    const lettersToReveal = Math.floor((revealPercent / 100) * currentWord.length);
    const visible = currentWord.slice(0, lettersToReveal);
    const hidden = currentWord.slice(lettersToReveal);
    if (lettersToReveal >= currentWord.length){
      inputAnswer.placeholder = `${currentWord}`;
    } else {
      inputAnswer.placeholder = `${visible}${'•'.repeat(Math.max(1, hidden.length))}`;
    }
  }

  // fetch definition from dictionaryapi.dev - try variants in order until one returns a definition
  async function fetchDefinitionForVariants(variants){
    if (!variants || !variants.length) return null;
    for (let v of variants){
      try {
        const url = 'https://api.dictionaryapi.dev/api/v2/entries/en/' + encodeURIComponent(v);
        const res = await fetch(url, {cache:'no-store'});
        if (!res.ok) {
          // 404 likely - try next variant
          continue;
        }
        const data = await res.json();
        // data is an array; take first meaning/definition available
        if (Array.isArray(data) && data.length){
          const entry = data[0];
          if (entry.meanings && entry.meanings.length){
            const meaning = entry.meanings[0];
            if (meaning.definitions && meaning.definitions.length){
              const def = meaning.definitions[0].definition;
              if (def) return def;
            }
          }
        }
      } catch(e){
        // network or parse error — try next variant
        console.warn('Definition fetch error for', v, e);
        continue;
      }
    }
    return null;
  }

  // helper that updates the visible hintLine when a definition is available
  function updateDisplayedDefinitionFor(word){
    // only update if word matches currentWord and setting is 'before'
    if (!word) return;
    if (settings.defTiming !== 'before') return;
    if (word !== currentWord) return; // stale fetch result
    const cached = definitionsCache[word];
    if (cached === undefined) {
      hintLine.textContent = 'Looking up definition…';
    } else if (cached === null) {
      hintLine.innerHTML = '<strong>Definition:</strong> Definition unavailable';
    } else {
      hintLine.innerHTML = `<strong>Definition:</strong> ${escapeHtml(cached)}`;
    }
  }

async function startNewRound(manual=false){
  if (manual && autoNextTimer){ clearTimeout(autoNextTimer); autoNextTimer = null; }

  // handle incomplete previous round (if there were attempts)
  if (!roundEnded && attemptsThisRound.length > 0){
    let best = 0; attemptsThisRound.forEach(a => { if (a.outcome === 'correct') best = Math.max(best, 1.0); else if (a.outcome === 'almost') best = Math.max(best, 0.6); });
    const used = attemptsThisRound.length;
    let multiplier = 0;
    if (settings.mode === 'easy'){ const map = {1:0.5,2:0.3,3:0.2,4:0.1}; multiplier = map[used] || 0; }
    else { multiplier = (used === 1 ? 0.3 : (used === 2 ? 0.1 : 0)); }
    const secs = Math.max(0.01, (performance.now() - roundStart) / 1000);
    const basePts = computePoints(best, currentWord, secs);
    const modeMult = getModeScoreMultiplier();
    const defMult  = getDefinitionTimingMultiplier();
    const awarded = Math.round(basePts * multiplier * modeMult * defMult);
    if (awarded > 0){ totalScore += awarded; updateScore(); showFloating(awarded, best===1 ? 'green' : (best>=0.6 ? 'yellow' : 'red')); }
    stats.push({ word: currentWord, attempts: attemptsThisRound.slice(), level: complexityInfo(currentWord).label, time: secs, points: awarded, correct: best===1, incomplete:true, mode: settings.mode });
    persistStats();
  }

  // reset state & UI
  lastSubmitted = null;
  attemptsThisRound = [];
  roundEnded = false;
  renderSegments();
  resetSegments();

  // reset input box styling and enable it
  inputAnswer.value = '';
  inputAnswer.disabled = false;
  inputAnswer.style.borderColor = '';     // reset to CSS default
  inputAnswer.style.background = 'transparent';
  inputAnswer.style.color = '';           // in case previous code changed it
  inputAnswer.placeholder = 'Type what you hear...';

  if (btnCheck) btnCheck.disabled = false;
  // hintLine now used for definitions; clear it at round start
  hintLine.textContent = '';

  // reset replay count & play button enable
  replayCount = 0;
  if (btnPlay){ btnPlay.disabled = false; }

  const level = settings.difficulty || 'proficient';
  currentWord = pickWordForDifficulty(level);
  roundStart = performance.now();

  // easy mode initial placeholder hint (instead of showing it below)
  if (settings.mode === 'easy'){
    // show just a tiny reveal to start (1 character or so)
    const reveal = Math.min(1, Math.ceil(currentWord.length * 0.05));
    const visible = currentWord.slice(0, reveal);
    const hidden = currentWord.slice(reveal);
    inputAnswer.placeholder = `${visible}${'•'.repeat(Math.max(1, hidden.length))}`;
  } else {
    inputAnswer.placeholder = 'Type what you hear...';
  }

  // prefetch definition as soon as the word is loaded (cached to reduce repeated calls)
  (async ()=>{
    try {
      // Only fetch if we don't have a cached key at all (i.e. undefined)
      if (definitionsCache[currentWord] === undefined) {
        const variantsToTry = (window.variantsMap && window.variantsMap[currentWord]) || [currentWord];
        // show looking up while fetching if 'before'
        if (settings.defTiming === 'before') hintLine.textContent = 'Looking up definition…';
        const def = await fetchDefinitionForVariants(variantsToTry);
        // store explicit null when missing so we won't loop forever
        definitionsCache[currentWord] = def || null;
        persistDefinitionsCache();
        // update UI if needed and if still on same word
        updateDisplayedDefinitionFor(currentWord);
      } else {
        // we already have an explicit cached value (possibly null); update immediately
        updateDisplayedDefinitionFor(currentWord);
      }
    } catch(e){
      console.warn('prefetch definition failed', e);
      // ensure UI doesn't stay stuck on "Looking up..." if something went wrong
      if (settings.defTiming === 'before') {
        hintLine.innerHTML = '<strong>Definition:</strong> Definition unavailable';
      }
    }
  })();

  // if user wants to see definition BEFORE guessing, display cached def immediately
  // (updateDisplayedDefinitionFor will also refresh once the fetch completes)
  if (settings.defTiming === 'before') {
    updateDisplayedDefinitionFor(currentWord);
  } else {
    // hide definition now (will show only after round ends)
    hintLine.textContent = '';
  }

  // automatic initial spoken audio (do not count towards hardcore replay limit)
  setTimeout(()=>{ 
    const u = new SpeechSynthesisUtterance(currentWord);
    if (settings.voice){
      const v = speechSynthesis.getVoices().find(x => x.name === settings.voice);
      if (v) u.voice = v;
    }
    u.rate = 0.95;
    speechSynthesis.cancel();
    speechSynthesis.speak(u);
    // intentionally do NOT set any separate result text
  }, 320);

  setTimeout(()=> inputAnswer.focus(), 700);
}

  function easyAttemptMultiplier(idx){ return ({1:1.0,2:0.8,3:0.6,4:0.4,5:0.2})[idx] || 0; }

// Replace your current onCheck() with this function
async function onCheck(){
  if (!currentWord) return;
  const raw = (inputAnswer.value || '').trim().toLowerCase();
  if (!raw) return;

  if (lastSubmitted !== null && raw === lastSubmitted){
    inputAnswer.animate([{transform:'translateX(0)'},{transform:'translateX(-6px)'},{transform:'translateX(6px)'},{transform:'translateX(0)'}], {duration:220});
    return;
  }
  lastSubmitted = raw;

  // get variants for the current canonical word
  const variants = (window.variantsMap && window.variantsMap[currentWord]) || [currentWord];

  // exact match: check against any variant
  const exact = variants.includes(raw);

  // similarity: take the best similarity between input and any variant
  let sim = 0;
  for (let v of variants){
    sim = Math.max(sim, similarityRatio(raw, v));
  }

  let outcome = 'wrong', correctness = 0;
  if (exact){ outcome = 'correct'; correctness = 1.0; }
  else if (sim >= 0.75){ outcome = 'almost'; correctness = 0.6; }

  attemptsThisRound.push({ value: raw, outcome });

  const idx = attemptsThisRound.length - 1;
  if (outcome === 'correct'){
    const usedBefore = attemptsThisRound.length - 1;
    mergeRemainingIntoGreen(usedBefore);
  } else {
    colorSegment(idx, outcome === 'almost' ? COLOR_YELLOW : COLOR_RED);
    if (settings.mode === 'easy') {
      inputAnswer.value = '';
      updateRevealHint(); // update placeholder hint after the wrong attempt
    }
  }

  if (settings.mode === 'easy') updateRevealHint();

  const secs = Math.max(0.01, (performance.now() - roundStart) / 1000);
  let pts = 0;
  const modeMult = getModeScoreMultiplier();
  const defMult = getDefinitionTimingMultiplier();
  if (outcome === 'correct'){
    if (settings.mode === 'easy'){
      const attemptNo = attemptsThisRound.length;
      const mult = easyAttemptMultiplier(attemptNo);
      pts = Math.round(computePoints(1.0, currentWord, secs) * mult * modeMult * defMult);
    } else {
      pts = Math.round(computePoints(1.0, currentWord, secs) * modeMult * defMult);
    }
    totalScore += pts; updateScore(); showFloating(pts, 'green');
  } else if (outcome === 'almost'){
    if (settings.mode === 'easy'){ pts = Math.round(computePoints(0.6, currentWord, secs) * easyAttemptMultiplier(attemptsThisRound.length) * modeMult * defMult); }
    else { pts = Math.round(computePoints(0.6, currentWord, secs) * modeMult * defMult); }
    totalScore += pts; updateScore(); showFloating(pts, 'yellow');
  } else {
    showFloating(0, 'red');
  }

  // endings per mode
  if (outcome === 'correct'){
    roundEnded = true;
    // show the correct answer IN the textbox (use displayMap to show combined display)
    inputAnswer.value = window.displayMap && window.displayMap[currentWord] ? window.displayMap[currentWord] : currentWord;
    inputAnswer.disabled = true;
    btnCheck.disabled = true;
    inputAnswer.style.borderColor = COLOR_GREEN;
    inputAnswer.style.background = 'rgba(76,175,80,0.06)';
    inputAnswer.style.color = '#111';

    // clear any separate resultText (textbox is now authoritative)
    resultText.textContent = '';

    stats.push({ word: currentWord, attempts: attemptsThisRound.slice(), level: complexityInfo(currentWord).label, time: secs, points: pts, correct:true, incomplete:false, mode: settings.mode });
    persistStats();

    // show definition under input using cached value if available (prefetch done at round start)
    const cached = definitionsCache[currentWord];
    if (cached !== undefined) {
      if (cached) hintLine.innerHTML = `<strong>Definition:</strong> ${escapeHtml(cached)}`;
      else hintLine.innerHTML = `<strong>Definition:</strong> Definition unavailable`;
    } else {
      // fallback: try fetch now (should be rare)
      hintLine.textContent = 'Looking up definition…';
      const variantsToTry = (window.variantsMap && window.variantsMap[currentWord]) || [currentWord];
      const def = await fetchDefinitionForVariants(variantsToTry);
      definitionsCache[currentWord] = def || null;
      persistDefinitionsCache();
      if (def) hintLine.innerHTML = `<strong>Definition:</strong> ${escapeHtml(def)}`;
      else hintLine.innerHTML = `<strong>Definition:</strong> Definition unavailable`;
    }

    if (settings.autoNext){
      if (autoNextTimer) clearTimeout(autoNextTimer);
      autoNextTimer = setTimeout(()=>{ startNewRound(false); autoNextTimer = null; }, 3000);
    }
  } else {
    const maxAttempts = settings.mode === 'easy' ? 5 : (settings.mode === 'hardcore' ? 1 : 3);
    if (attemptsThisRound.length >= maxAttempts){
      roundEnded = true;
      btnCheck.disabled = true;

      // show correct answer IN the textbox (display combined form), mark failure
      inputAnswer.value = window.displayMap && window.displayMap[currentWord] ? window.displayMap[currentWord] : currentWord;
      inputAnswer.disabled = true;
      inputAnswer.style.borderColor = COLOR_RED;
      inputAnswer.style.background = 'rgba(244,67,54,0.06)';
      inputAnswer.style.color = '#111';

      resultText.textContent = '';

      colorAllSegments(COLOR_RED);
      stats.push({ word: currentWord, attempts: attemptsThisRound.slice(), level: complexityInfo(currentWord).label, time: secs, points: 0, correct:false, incomplete:false, mode: settings.mode });
      persistStats();

      // show definition (use cached prefetched value)
      if (settings.defTiming === 'after') {
      // set hintLine (use cached definition if possible)
        const cached = definitionsCache[currentWord];
        if (cached !== undefined) {
          if (cached) hintLine.innerHTML = `<strong>Definition:</strong> ${escapeHtml(cached)}`;
          else hintLine.innerHTML = `<strong>Definition:</strong> Definition unavailable`;
        } else {
          hintLine.textContent = 'Looking up definition…';
          const variantsToTry = (window.variantsMap && window.variantsMap[currentWord]) || [currentWord];
          const def = await fetchDefinitionForVariants(variantsToTry);
          definitionsCache[currentWord] = def || null;
          persistDefinitionsCache();
          if (def) hintLine.innerHTML = `<strong>Definition:</strong> ${escapeHtml(def)}`;
          else hintLine.innerHTML = `<strong>Definition:</strong> Definition unavailable`;
          }
      } 

      

      if (settings.autoNext){ if (autoNextTimer) clearTimeout(autoNextTimer); autoNextTimer = setTimeout(()=>{ startNewRound(false); autoNextTimer = null; }, 3000); }
    } else {
      if (settings.mode !== 'hardcore') {
        inputAnswer.value = ''; inputAnswer.focus();
      } else {
        // hardcore: only 1 attempt allowed -> disable input
        inputAnswer.value = ''; inputAnswer.disabled = true; btnCheck.disabled = true;
      }
    }
  }
}

  // Stats rendering
  function renderStats(){
    statsList.innerHTML = '';
    const total = stats.length;
    const correct = stats.filter(s => s.correct).length;
    const acc = total ? Math.round(1000*(correct/total))/10 : 0;
    statsSummary.textContent = `Total: ${total} | Accuracy: ${acc}%`;

    stats.slice().reverse().forEach(s=>{
      const row = document.createElement('div'); row.className = 'stat-row';
      const left = document.createElement('div'); left.className = 'stat-left';
      const title = document.createElement('div'); title.textContent = s.word; title.style.fontWeight = '700';
      left.appendChild(title);
      if (s.mode === 'easy'){
        const icon = document.createElement('i'); icon.className = 'fa-solid fa-feather'; icon.style.color = '#7aa'; icon.style.fontSize = '14px';
        left.appendChild(icon);
      }
      const right = document.createElement('div'); right.className = 'stat-right';
      const segCount = (s.mode === 'easy') ? 5 : (s.mode === 'hardcore' ? 1 : 3);
      const mini = document.createElement('div'); mini.className = 'mini-bar';
      for (let i=0;i<segCount;i++){
        const ms = document.createElement('div'); ms.className = 'mini-seg'; ms.style.background = COLOR_NEUTRAL;
        if (i < s.attempts.length){
          const a = s.attempts[i];
          if (a.outcome === 'correct') ms.style.background = COLOR_GREEN;
          else if (a.outcome === 'almost') ms.style.background = COLOR_YELLOW;
          else ms.style.background = COLOR_RED;
          // unified hover + tap handler that works on mobile (taps)
          ms.addEventListener('mouseenter', (ev)=>{
            if (window.matchMedia('(hover: hover)').matches){
              const r = ev.target.getBoundingClientRect();
              const text = `${capitalize(a.outcome)}: ${a.value}`;
              const bg = a.outcome === 'correct' ? COLOR_GREEN : (a.outcome === 'almost' ? COLOR_YELLOW : COLOR_RED);
              const txt = (a.outcome === 'almost' ? '#111' : '#fff');
              showMiniTooltip(r.left + r.width/2, r.top, text, bg, txt);
            }
          });
          ms.addEventListener('mouseleave', ()=>{
            if (window.matchMedia('(hover: hover)').matches) hideMiniTooltip();
          });

          ms.addEventListener('click', (ev)=>{
            if (!window.matchMedia('(hover: hover)').matches){
              ev.stopPropagation();
              const r = ev.target.getBoundingClientRect();
              const text = `${capitalize(a.outcome)}: ${a.value}`;
              const bg = a.outcome === 'correct' ? COLOR_GREEN : (a.outcome === 'almost' ? COLOR_YELLOW : COLOR_RED);
              const txt = (a.outcome === 'almost' ? '#111' : '#fff');
              const already = miniTooltip !== null;
              hideMiniTooltip();
              if (!already) showMiniTooltip(r.left + r.width/2, r.top, text, bg, txt);
            }
          });
        }
        mini.appendChild(ms);
      }
      const ptsBox = document.createElement('div'); ptsBox.style.minWidth = '64px'; ptsBox.style.textAlign = 'right'; ptsBox.style.fontWeight = '700';
      ptsBox.textContent = `${s.points} pts`;
      right.appendChild(mini); right.appendChild(ptsBox);
      row.appendChild(left); row.appendChild(right);
      statsList.appendChild(row);
    });
  }

  btnClearStats.addEventListener('click', ()=>{ if (!confirm('Are you sure you want to wipe your statistics? This cannot be undone.')) return; stats = []; persistStats(); renderStats(); });

  // Settings UI
  function renderSettings(){
    // difficulty buttons
    Array.from(segDifficulty.querySelectorAll('button')).forEach(b => b.classList.toggle('on', b.dataset.val === settings.difficulty));
    // mode buttons
    Array.from(segMode.querySelectorAll('button')).forEach(b => b.classList.toggle('on', b.dataset.val === settings.mode));
    // definition timing buttons
    if (typeof segDefinitionTiming !== 'undefined') {
      Array.from(segDefinitionTiming.querySelectorAll('button')).forEach(b => b.classList.toggle('on', b.dataset.val === settings.defTiming));
    }
  }

  segDifficulty.addEventListener('click',(e)=>{ if (e.target.tagName!=='BUTTON') return; settings.difficulty = e.target.dataset.val; persistSettings(); renderSettings(); startNewRound(false); });

  if (segDefinitionTiming) {
  Array.from(segDefinitionTiming.querySelectorAll('button')).forEach(btn=>{
    btn.addEventListener('click', (e)=>{
      const val = btn.dataset.val || 'before';
      settings.defTiming = val;
      persistSettings();
      renderSettings();
    });
  });
}
  
  // Tooltips for mode and difficulty (mobile-friendly)
  const modeTooltips = {
    easy: '5 attempts, progressive hints',
    normal: '3 attempts, no help',
    hardcore: '1 attempt, limited audio replays'
  };
  const difficultyTooltips = {
    easy: 'A1-A2 level words',
    advanced: 'B1-B2 level words',
    proficient: 'C1-C2 level words'
  };

  function attachTooltipHandlers(button, text){
    button.addEventListener('mouseenter',(e)=>{
      if (window.matchMedia('(hover: hover)').matches){
        const r = e.target.getBoundingClientRect();
        showMiniTooltip(r.left + r.width/2, r.top, text, '#444', '#fff');
      }
    });
    button.addEventListener('mouseleave',(e)=>{
      if (window.matchMedia('(hover: hover)').matches) hideMiniTooltip();
    });
    button.addEventListener('click',(e)=>{
      if (!window.matchMedia('(hover: hover)').matches){
        const r = e.target.getBoundingClientRect();
        const already = miniTooltip !== null;
        hideMiniTooltip();
        if (!already) showMiniTooltip(r.left + r.width/2, r.top, text, '#444', '#fff');
      }
    });
  }

  Array.from(segMode.querySelectorAll('button')).forEach(btn=>{
    attachTooltipHandlers(btn, modeTooltips[btn.dataset.val] || '');
    btn.addEventListener('click',(e)=>{ settings.mode = e.target.dataset.val; persistSettings(); renderSettings(); renderSegments(); startNewRound(false); });
  });
  Array.from(segDifficulty.querySelectorAll('button')).forEach(btn=>{
    attachTooltipHandlers(btn, difficultyTooltips[btn.dataset.val] || '');
  });

  // Auto next toggle (single game control only)
  function setAutoNext(enabled){
    settings.autoNext = !!enabled;
    persistSettings();
    if (autoNextBtn) {
      if (settings.autoNext) { autoNextBtn.classList.add('checked'); autoNextBtn.setAttribute('aria-pressed','true'); }
      else { autoNextBtn.classList.remove('checked'); autoNextBtn.setAttribute('aria-pressed','false'); }
    }
  }
  if (autoNextBtn) autoNextBtn.addEventListener('click', ()=> setAutoNext(!settings.autoNext));

  // TTS voice population
  function populateVoices(){
    const voices = speechSynthesis.getVoices();
    voiceSelect.innerHTML = '';
    if (!voices || !voices.length){
      const opt = document.createElement('option'); opt.value=''; opt.textContent='(Default browser voice)'; voiceSelect.appendChild(opt); return;
    }
    const fallbackOpt = document.createElement('option'); fallbackOpt.value=''; fallbackOpt.textContent='(Default browser voice)'; voiceSelect.appendChild(fallbackOpt);
    voices.forEach(v=>{
      const opt = document.createElement('option');
      opt.value = v.name;
      opt.textContent = `${v.name}${v.lang ? ' — '+v.lang : ''}${v.default ? ' (default)' : ''}`;
      voiceSelect.appendChild(opt);
    });
    if (settings.voice) {
      const match = Array.from(voiceSelect.options).find(o => o.value === settings.voice);
      if (match) voiceSelect.value = settings.voice;
    }
  }
  speechSynthesis.addEventListener('voiceschanged', populateVoices);
  voiceSelect.addEventListener('change', ()=> { settings.voice = voiceSelect.value || ''; persistSettings(); });

  // Utility UI helpers
function updateScore(){
  const el = document.getElementById('scoreValue');
  if (el) el.textContent = String(totalScore);
}
  
  // Play button handler - counts user replay attempts in hardcore mode
  btnPlay.addEventListener('click', ()=>{
    if (!currentWord) { return; }
    // For hardcore, block after HARDCORE_MAX_REPLAYS
    if (settings.mode === 'hardcore'){
      if (replayCount >= HARDCORE_MAX_REPLAYS){
        btnPlay.disabled = true;
        return;
      }
      // user-initiated replay increments count
      replayCount++;
      if (replayCount >= HARDCORE_MAX_REPLAYS){
        // disable immediately to reflect block
        btnPlay.disabled = true;
      }
    }
    // speak
    const u = new SpeechSynthesisUtterance(currentWord);
    if (settings.voice){
      const v = speechSynthesis.getVoices().find(x => x.name === settings.voice);
      if (v) u.voice = v;
    }
    u.rate = 0.95;
    speechSynthesis.cancel();
    speechSynthesis.speak(u);
  });

  btnNext.addEventListener('click', ()=>{ if (autoNextTimer){ clearTimeout(autoNextTimer); autoNextTimer = null; } startNewRound(true); });
  btnCheck.addEventListener('click', onCheck);
  inputAnswer.addEventListener('keydown', (e)=>{ if (e.key === 'Enter'){ e.preventDefault(); onCheck(); } });

  // Tabs
  tabGame.addEventListener('click', ()=>{ pageGame.style.display=''; pageStats.style.display='none'; pageSettings.style.display='none'; tabGame.classList.add('active'); tabStats.classList.remove('active'); tabSettings.classList.remove('active'); });
  tabStats.addEventListener('click', ()=>{ pageStats.style.display=''; pageGame.style.display='none'; pageSettings.style.display='none'; tabStats.classList.add('active'); tabGame.classList.remove('active'); tabSettings.classList.remove('active'); renderStats(); });
  tabSettings.addEventListener('click', ()=>{ pageSettings.style.display=''; pageGame.style.display='none'; pageStats.style.display='none'; tabSettings.classList.add('active'); tabGame.classList.remove('active'); tabStats.classList.remove('active'); renderSettings(); });

  // Init
  (async function init(){
    await loadWords();
    renderSegments();
    renderSettings();
    renderStats();
    updateScore();
    populateVoices();
    setTimeout(populateVoices,600);
    setAutoNext(!!settings.autoNext);
    startNewRound(false);
  })();

  
  // persist
  window.addEventListener('beforeunload', ()=>{ persistSettings(); persistStats(); persistDefinitionsCache(); });

  // global click to close tooltip
  document.addEventListener('click',(e)=>{ if (miniTooltip && !miniTooltip.contains(e.target)) hideMiniTooltip(); });

})();
  
</script>
</body>
</html>
